
import os
import numpy as np
import matplotlib.pyplot as plt
import concurrent.futures

from src.dla_fin_diff import *
from src.utils import *




      
def count_non_converged(eta, omega_0, num_runs=100, grid_size=100, adaptive_SOR = False):    
    """
    run a number of growth experiments with constant parameters and count in how many of them the finite difference method diverged 
    :
        eta:        growth parameter
        omega_0:    initial omega for SOR
        adaptive_SOR: decides whether the omega is reduced for better stability or not
        num_runs:   num_runs
        grid_size:  size of grid
        
        
    returns:
        non_converged:      number of failed runs
        mean_sor_iter:      mean number of finite-difference time steps of successful runs
        std_sor_iter:      standard deviation of number of finite-difference time steps of successful runs
    """  
    
    initial_cond = np.zeros([grid_size, grid_size])
    initial_cond[-2, grid_size//2] = 1
    sor_iters =np.zeros(num_runs)
    non_converged=0
    for i in range(num_runs):    
        try:        
            g, c , num_iter, sor_iter= dla_growth(eta, omega_0, initial_cond, growth_steps=10000, diffusion_tolerance=1e-5, adaptive_SOR=adaptive_SOR, verbose=False)
            sor_iters[i] =sor_iter
        except:
            non_converged +=1
    mean_sor_iter = np.sum(sor_iters) / (num_runs-non_converged) if non_converged < num_runs else np.inf
    std_sor_iter = np.std(sor_iters[sor_iters>0])
    print(omega_0, (num_runs-non_converged), non_converged, mean_sor_iter, std_sor_iter)
    return non_converged, mean_sor_iter, std_sor_iter

def non_conv_experiment(eta, file=os.path.join('data', 'opt_omega')):
    """
    run a number of growth experiments with varyious parameters and count in how many of them the finite difference method diverged 
    all results are saved to a file
    :
        eta:        growth parameter
        omegas:     array of initial omega (for SOR) to test
        num_runs:   number of runs for each parameter set
        file:       location for storing data
        
        
    returns:
    stored in file:
        omegas:         copy of input
        non_converged:  number of failed runs
        mean_sor_iter:  mean number of finite-difference time steps of successful runs
        std_sor_iter:   standard deviation of number of finite-difference time steps of successful runs
    """      
    np.random.seed(42)
    set_numba_seed(np.random.randint(1000000000))
    
    omegas = [1.5, 1.55, 1.6, 1.65, 1.7, 1.75, 1.8, 1.85, 1.9, 1.95, 2]
    num_runs = 100
    
    non_conv = np.zeros([len(omegas), 2])
    mean_iters = np.zeros([len(omegas), 2])
    std_iters = np.zeros([len(omegas), 2])
    for i in range(len(omegas)):
        omega_0 = omegas[i]
        print('adaptive')
        non_converged, mean_sor_iter, std_sor_iter= count_non_converged(eta, omega_0, num_runs=num_runs, adaptive_SOR=True)
        non_conv[i, 0] = non_converged
        mean_iters[i, 0] = mean_sor_iter
        std_iters[i, 0] = mean_sor_iter
        print('non-adaptive')
        non_converged, mean_sor_iter, std_sor_iter = count_non_converged(eta, omega_0, num_runs=num_runs, adaptive_SOR=False)
        non_conv[i, 1] = non_converged
        mean_iters[i, 1] = mean_sor_iter
        std_iters[i, 1] = mean_sor_iter
        
    np.savez((file + str(eta)), omegas, non_conv, mean_iters, std_iters)
        
def plot_non_conv(file=os.path.join('data', 'opt_omega.npz'), num_runs=20, plot_file=None):
    """
    analyze and plot the data generated by non_conv_experiment 
    :
        file:       location of stored data
        num_runs:   number of runs for each datapoint
        plot_file:  location for saving plot
        
        
    returns:
        dual y-axis plot of number of SOR iterations with error bars and failure rate 
    """  
    fig, ax = plt.subplots(figsize=[4,4])
    # plt.locator_params(axis='y', nbins=4)
    arrs  = np.load(file)
    titles = ['adaptive', 'non-adaptive']
    omegas, non_conv, mean_iters, std_iters = [arrs['arr_{}'.format(i)] for i in range(4)]
    for i, title in enumerate(titles):
        err = 1.96 * std_iters[:,i] / np.sqrt(num_runs)
        # print(err)
        ax.errorbar(omegas, mean_iters[:,i], yerr=err, label=title, linestyle='', marker='o', capsize=4, alpha=0.8)
    ax2 = ax.twinx()
    ax2.bar(omegas, non_conv[:,1]/num_runs, alpha=0.5, width=0.04, color='r')
    ax2.set_ylabel('failure rate', fontsize=16)
    ax2.set_ylim([0,2])
    ax2.tick_params(labelsize=16)
    ax2.set_yticks([0,1], [0,1])
    ax.set_ylabel('$t_{SOR}$', fontsize=16)
    ax.set_xlabel(r'$\omega$', fontsize=16)
    ax.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
    ax.tick_params(labelsize=16)
    ax.legend(fontsize=16)
    ax.grid()
    fig.tight_layout()
    
    print(plot_file)
    if plot_file is not None:
        plt.savefig(plot_file, dpi=600)
    plt.show()
        
def parallel_non_conv(etas):
    """
    run the non_conv_experiment function in parallel for different values of eta
    """
    with concurrent.futures.ProcessPoolExecutor() as executor:
        future_f = [executor.submit(non_conv_experiment, eta, os.path.join('data', 'opt_omega')) for eta in etas]


def main():
    #run the experiments
    # etas = [0, 0.125, 0.5, 1, 2, 8]
    # parallel_non_conv(etas)
    
    #plot the results
    etas = [0.5, 1, 2, 8]
    num_runs=100
    for eta in etas:
        filename = os.path.join('data', 'opt_omega') + str(eta) + '.npz'
        plot_file_name = os.path.join('results','diffusion_limited_aggregation', 'opt_omega') + str(eta) + '.png'
        plot_non_conv(filename, num_runs, plot_file_name)


if __name__ == '__main__':
    main()
    
    
    
    
    
    